#!/usr/bin/env bash
#Send stats, receives commands

INTERVAL=10
RIG_CONF="/hive-config/rig.conf"
NVIDIA_OC_CONF="/hive-config/nvidia-oc.conf"
AMD_OC_CONF="/hive-config/amd-oc.conf"
WALLET_CONF="/hive-config/wallet.conf"
LOG="/var/log/hive-agent.log"

API_TIMEOUT=15 #timeout to wait for miner API response, can take very long time on 13+ gpus

[ -t 1 ] && . colors

#$PPID - might be parent screen pid
screen_count=`screen -ls | grep "\.agent" | grep -v $PPID | wc -l`

#there will be still 1 process for subshell
#[[ `ps aux | grep "./agent" | grep -vE "grep|screen|SCREEN|$$" | wc -l` > 1 ]] &&
[[ $screen_count > 0 ]] &&
	echo -e "${RED}Agent screen is already running${NOCOLOR}\nRun ${CYAN}agent-screen${NOCOLOR} to resume screen" &&
	exit 1



#{"temp":["61","42","41"],"fan":["92","0","0"],"load":["92","0","0"],"busids":["01:00.0","03:00.0","05:00.0"]}
gpu_stats=


#Nvidia indexes in aa [1,2,3] to use in jsons
#nvidia_indexes=echo "$gpu_stats" | jq '.brand | to_entries[] | select(.value == "nvidia") | .key' | jq -sc '.'
#nvidia_indexes=`gpu-detect listjson | jq '. | to_entries[] | select(.value.brand == "nvidia") | .key' | jq -sc '.'`
nvidia_indexes_array=`gpu-detect listjson | jq -c '[ . | to_entries[] | select(.value.brand == "nvidia") | .key ]'`
cpu_indexes_array=`gpu-detect listjson | jq -c '[ . | to_entries[] | select(.value.brand == "cpu") | .key ]'`

########################################################################################################################

function miner_stats {
	local miner=$1
	local mindex=$2 #empty or 2

	khs=0
	stats=
	case $miner in
		claymore)
			stats=`echo '{"id":0,"jsonrpc":"2.0","method":"miner_getstat1"}' | nc -w $API_TIMEOUT localhost 3333 | jq '.result'`
			if [[ $? -ne 0  || -z $stats ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:3333${NOCOLOR}"
			else
				#[ "10.0 - ETH", "83", "67664;48;0", "28076;27236;12351", "891451;29;0", "421143;408550;61758", "67;40;70;45;69;34", "eth-eu1.nanopool.org:9999;sia-eu1.nanopool.org:7777", "0;0;0;0" ]
				khs=`echo $stats | jq -r '.[2]' | awk -F';' '{print $1}'`
				algo=`cat /hive/claymore/config.txt | grep -m1 --text "^\-dcoin" | sed 's/-dcoin //'`
				stats=`echo "$stats" "[\"$algo\"]" | jq -s '.[0] + .[1]'` # push algo to end of array
			fi
		;;
		claymore-x)
			stats=`echo '{"id":0,"jsonrpc":"2.0","method":"miner_getstat1"}' | nc -w $API_TIMEOUT localhost 3337 | jq '.result'`
			if [[ $? -ne 0  || -z $stats ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:3337${NOCOLOR}"
			else
				khs=`echo $stats | jq -r '.[2]' | awk -F';' '{print $1/1000}'` #sols to khs
			fi
		;;
		claymore-z)
			stats=`echo '{"id":0,"jsonrpc":"2.0","method":"miner_getstat1"}' | nc -w $API_TIMEOUT localhost 3335 | jq '.result'`
			if [[ $? -ne 0  || -z $stats ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:3335${NOCOLOR}"
			else
				khs=`echo $stats | jq -r '.[2]' | awk -F';' '{print $1/1000}'` #sols to khs
			fi
		;;
		ewbf)
			#0000:03:00.0, .result[].busid[5:] trims first 5 chars
			#stats_raw=`curl --connect-timeout 2 --max-time $API_TIMEOUT --silent --noproxy '*' http://localhost:42000/getstat`
			#curl uses http_proxy env var, we don't need it. --noproxy does not work
			stats_raw=`echo "GET /getstat" | nc -w $API_TIMEOUT localhost 42000 | tail -n 1`
			if [[ $? -ne 0  || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:42000${NOCOLOR}"
			else
				stats=`echo $stats_raw | jq -c '{speed_sps: [.result[].speed_sps], busid: [.result[].busid[5:]|ascii_downcase], start_time: .result[0].start_time}'`
				khs=`echo $stats_raw | jq -r '.result[].speed_sps' | awk '{s+=$1} END {print s/1000}'` #sum up and convert to khs
			fi
		;;
		ccminer)
			threads=`echo "threads" | nc -w $API_TIMEOUT localhost 4068` #&& echo $threads
			if [[ $? -ne 0  || -z $threads ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4068${NOCOLOR}"
			else
				summary=`echo "summary" | nc -w 2 localhost 4068`
				re=';UPTIME=([0-9]+);' && [[ $summary =~ $re ]] && local uptime=${BASH_REMATCH[1]} #&& echo "Matched" || echo "No match"
				#khs will calculate from cards; re=';KHS=([0-9\.]+);' && [[ $summary =~ $re ]] && khs=${BASH_REMATCH[1]} #&& echo "Matched" || echo "No match"
				algo=`echo "$summary" | tr ';' '\n' | grep -m1 'ALGO=' | sed -e 's/.*=//'`
				#stats=`echo $threads | tr '|' '\n' | tr ';' '\n' | tr -cd '\11\12\15\40-\176' | grep -E 'KHS=' | sed -e 's/.*=//' | jq -cs '{khs:.}'`
				striplines=`echo "$threads" | tr '|' '\n' | tr ';' '\n' | tr -cd '\11\12\15\40-\176'`

				#if GPU has 0.0 temp it hanged. ccminer does not mine on this card but shows hashrate
				cctemps=(`echo "$striplines" | grep 'TEMP=' | sed -e 's/.*=//'`) #echo ${cctemps[@]} | tr " " "\n" #print it in lines
				cckhs=(`echo "$striplines" | grep 'KHS=' | sed -e 's/.*=//'`)
				ccbusids=(`echo "$striplines" | grep 'BUS=' | sed -e 's/.*=//'`)


				#local nvidiastats
				for (( i=0; i < ${#cckhs[@]}; i++ )); do
					#if temp is 0 then driver or GPU failed
					[[ ${cctemps[$i]} == "0.0" ]] && cckhs[$i]="0.0"

					#cckhs[$i]="84316579.94" #test
					#check Ghs. 1080ti gives ~64mh (64000kh) on lyra. when it's showing ghs then load is 0 on gpu
					#if [[ `echo ${cckhs[$i]} | awk '{ print ($1 >= 1000000) ? 1 : 0 }'` == 1 ]]; then #hash is in Ghs, >= 1000000 khs
					if [[ `echo ${cckhs[$i]} | awk '{ print ($1 >= 1000) ? 1 : 0 }'` == 1 ]]; then # > 1Mh
						#[[ -z $nvidiastats ]] && nvidiastats=`gpu-stats nvidia` #a bit overhead in calling nvidia-smi again
						local busid=`echo ${ccbusids[$i]} | awk '{ printf("%02x:00.0", $1) }'` #ccbus is decimal
						local load_i=`echo "$gpu_stats" | jq ".busids|index(\"$busid\")"`
						if [[ $load_i != "null" ]]; then #can be null on failed driver
							local load=`echo "$gpu_stats" | jq -r ".load[$load_i]"`
							#load=0 #test
							[[ -z $load || $load -le 10 ]] &&
								echo -e "${RED}Hash on GPU$i is in GH/s (${cckhs[$i]} kH/s) but Load is detected to be only $load%${NOCOLOR}" &&
								cckhs[$i]="0.0"
						fi
					fi

					#khs=`echo $khs ${cckhs[$i]} | awk '{ printf("%.3f", $1 + $2) }'`
					khs=`echo $khs ${cckhs[$i]} | awk '{ printf("%.3f", $1 + $2) }'`
				done

				khs=`echo $khs | sed -E 's/^( *[0-9]+\.[0-9]([0-9]*[1-9])?)0+$/\1/'` #1234.100 -> 1234.1

				stats=$(jq -n \
					--arg uptime "$uptime", --arg algo "$algo" \
					--argjson khs "`echo ${cckhs[@]} | tr " " "\n" | jq -cs '.'`" \
					--argjson temp "`echo ${cctemps[@]} | tr " " "\n" | jq -cs '.'`" \
					--argjson fan "`echo \"$striplines\" | grep 'FAN=' | sed -e 's/.*=//' | jq -cs '.'`" \
					'{$khs, $temp, $fan, $uptime, $algo}')
			fi
		;;
		ethminer)
			stats_raw=`echo '{"id":0,"jsonrpc":"2.0","method":"miner_getstat1"}' | nc -w $API_TIMEOUT localhost 3334 | jq '.result'`
			if [[ $? -ne 0  || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats_raw from localhost:3334${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq -r '.[2]' | awk -F';' '{print $1}'`
				#`echo $stats_raw | jq -r '.[3]' | awk 'gsub(";", "\n")' | jq -cs .` #send only hashes
				local tempfans=`echo $stats_raw | jq -r '.[6]'` #"56;26; 48;42"
				local temp=()
				local fan=()
				for tf in $tempfans; do
					temp+=(`echo $tf | awk -F';' '{print $1}'`)
					fan+=(`echo $tf | awk -F';' '{print $2}'`)
				done
				temp=`printf '%s\n' "${temp[@]}" | jq --raw-input . | jq --slurp -c .`
				fan=`printf '%s\n' "${fan[@]}" | jq --raw-input . | jq --slurp -c .`

				#ethminer API can show hashes, but no load... hard to fix it here
				#local hs=(`echo "$stats_raw" | jq -r '.[3]' | tr ';' ' '`)
				#echo ${hs[0]}

				local hs=`echo "$stats_raw" | jq -r '.[3]' | tr ';' '\n' | jq -cs '.'`
				stats=$(jq -n \
					--arg uptime "`echo \"$stats_raw\" | jq -r '.[1]' | awk '{print $1*60}'`" \
					--argjson hs "$hs" \
					--argjson temp "$temp" --argjson fan "$fan" \
					'{$hs, $temp, $fan, $uptime}')
			fi
		;;
		sgminer-gm)
			stats_raw=`echo '{"command":"summary+devs"}' | nc -w $API_TIMEOUT localhost 4028`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:4028${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq '.["summary"][0]["SUMMARY"][0]["KHS 15s"]'`
				stats=`echo $stats_raw | jq '{khs: [.devs[0].DEVS[]."KHS 15s"], temp: [.devs[0].DEVS[].Temperature], \
						fan: [.devs[0].DEVS[]."Fan Percent"], uptime: .summary[0].SUMMARY[0].Elapsed, algo: "'$SGMINER_GM_ALGO'"}'`
			fi
		;;
		dstm)
			stats_raw=`echo '{"id":1, "method":"getstat"}' | nc -w $API_TIMEOUT localhost 43000`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:43000${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq '.result[].sol_ps' | awk '{s+=$1} END {print s/1000}'`
				local uptime=$(( `date +%s` - $(stat -c%X /proc/`pidof zm`) )) #dont think zm will die so soon after getting stats
				#todo: use gpu_stats if busid is known
				#local nvidiastats=`gpu-stats nvidia` #a bit overhead in calling nvidia-smi again, shame on dstm, he gives no temps
				#stats=`echo $stats_raw | jq '{ hs: [.result[].sol_ps], temp: [.result[].temperature], uptime: "'$uptime'"}'`
				#stats=$(jq '{ hs: [.result[].sol_ps], uptime: "'$uptime'"}' <<< $stats_raw)
				#stats=$(jq -s '.[0] * .[1]' <<< "$stats $nvidiastats")
				local fan=$(jq -c "[.fan$nvidia_indexes_array]" <<< $gpu_stats)
				local temp=$(jq -c "[.temp$nvidia_indexes_array]" <<< $gpu_stats)
				stats=$(jq --argjson temp "$temp" --argjson fan "$fan" --arg uptime "$uptime" '{ hs: [.result[].sol_ps], $temp, $fan, $uptime}' <<< $stats_raw)
			fi
		;;
		bminer) #@see https://www.bminer.me/references/
			stats_raw=`curl --connect-timeout 2 --max-time $API_TIMEOUT --silent --noproxy '*' http://127.0.0.1:1880/api/status`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:1880${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq '.miners[].solver.solution_rate' | awk '{s+=$1} END {print s/1000}'`
				local uptime=$(( `date +%s` - $(stat -c%X /proc/`pidof bminer | awk '{print $1}'`) )) #in seconds
				local fan=$(jq -c "[.fan$nvidia_indexes_array]" <<< $gpu_stats)
				local temp=$(jq -c "[.temp$nvidia_indexes_array]" <<< $gpu_stats)
				#fucking bminer sorts it's keys as numerics, not natual, e.g. "1", "10", "11", "2", fix that with sed hack by replacing "1":{ with "01":{
				local hs=$(echo "$stats_raw" | sed -E 's/"([0-9])":\s*\{/"0\1":\{/g' | jq --sort-keys . | jq -c "[.miners[].solver.solution_rate]")
				#stats=$(jq --argjson fan "$fan" --arg uptime "$uptime" '{hs: [.miners[].solver.solution_rate], temp: [.miners[].device.temperature], $fan, $uptime}' <<< $stats_raw)
				stats=$(jq -nc --argjson hs "$hs" --argjson temp "$temp" --argjson fan "$fan" --arg uptime "$uptime" '{$hs, $temp, $fan, $uptime}')
			fi
		;;
		xmr-stak)
			stats_raw=`curl --connect-timeout 2 --max-time $API_TIMEOUT --silent --noproxy '*' http://127.0.0.1:60045/api.json`
			#echo $stats_raw | jq .
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:60045${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq -r '.hashrate.total[0]' | awk '{print $1/1000}'`
				local cpu_temp=`cat /sys/class/thermal/thermal_zone*/temp | head -n $(nproc) | awk '{print $1/1000}' | jq -rsc .` #just a try to get CPU temps
				local gpus_disabled=
				(head /hive/xmr-stak/xmr-stak.log | grep -q "WARNING: backend AMD disabled") && #AMD disabled found
				(head /hive/xmr-stak/xmr-stak.log | grep -q "WARNING: backend NVIDIA disabled") && #and nvidia disabled
				gpus_disabled=1
				#local amd_on=$(head /hive/xmr-stak/xmr-stak.log | grep -q -E "WARNING: backend (NVIDIA|AMD) disabled")
				if [[ $gpus_disabled == 1 ]]; then #gpus disabled
					local temp='[]'
					local fan='[]'
				else
					local temp=$(jq '.temp' <<< $gpu_stats)
					local fan=$(jq '.fan' <<< $gpu_stats)
					[[ $cpu_indexes_array != '[]' ]] && #remove Internal Gpus
						temp=$(jq -c "del(.$cpu_indexes_array)" <<< $temp) &&
						fan=$(jq -c "del(.$cpu_indexes_array)" <<< $fan)
				fi
				#temp=$(jq -sc '.[0] + .[1]'  <<< "$temp $cpu_temp")
				#fan=$(jq -sc '.[0] + .[1]'  <<< "$fan [-1]")
				stats=$(jq --argjson temp "$temp" --argjson fan "$fan" --argjson cpu_temp "$cpu_temp" '{hs: [.hashrate.threads[][0]], $temp, $fan, $cpu_temp, uptime: .connection.uptime}' <<< $stats_raw)
			fi
		;;
		xmr-stak-cpu)
			stats_raw=`curl --connect-timeout 2 --max-time $API_TIMEOUT --silent --noproxy '*' http://127.0.0.1:60044/api.json`
			#echo $stats_raw | jq .
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:60044${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq -r '.hashrate.total[0]' | awk '{print $1/1000}'`
				#to do : lm-sensors
				local cpu_temp=`cat /sys/class/thermal/thermal_zone*/temp | head -n $(nproc) | awk '{print $1/1000}' | jq -rsc .` #just a try to get CPU temps
				stats=`echo $stats_raw | jq '{hs: [.hashrate.threads[][0]], temp: '$cpu_temp', uptime: .connection.uptime}'`
			fi
		;;
		xmrig)
			stats_raw=`curl --connect-timeout 2 --max-time $API_TIMEOUT --silent --noproxy '*' http://127.0.0.1:60050`
			#echo $stats_raw | jq .
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner from localhost:60050${NOCOLOR}"
			else
				khs=`echo $stats_raw | jq -r '.hashrate.total[0]' | awk '{print $1/1000}'`
				local cpu_temp=`cat /sys/class/thermal/thermal_zone*/temp | head -n $(nproc) | awk '{print $1/1000}' | jq -rsc .` #just a try to get CPU temps
				stats=`echo $stats_raw | jq '{hs: [.hashrate.threads[][0]], temp: '$cpu_temp', uptime: .connection.uptime}'`
			fi
		;;
		*)
			miner="unknown"
			#MINER=miner
			eval "MINER${mindex}=unknown"
		;;
	esac


	[[ -z $khs ]] && khs=0
	[[ -z $stats ]] && stats="null"

#	[[ ! -z $mindex ]] &&
#		eval "khs${mindex}"
}


########################################################################################################################

function loop {
	date

	[ ! -f $RIG_CONF ] && echo -e "No config $RIG_CONF" && return

	#each time read config again
	. $RIG_CONF
	. $WALLET_CONF

	[ -z $MINER ] && MINER="claymore"
	HIVE_URL="$HIVE_HOST_URL/worker/api"

	gpu_stats=`gpu-stats`
	local temp=$(jq '.temp' <<< $gpu_stats)
	local fan=$(jq '.fan' <<< $gpu_stats)
	local power=$(jq '.power' <<< $gpu_stats)


	miner2_json=
	if [[ ! -z $MINER2 ]]; then
		miner_stats $MINER2 2
		khs2=$khs
		miner2_json=$(jq -n --arg miner2 "$MINER2" --arg total_khs2 "$khs" --argjson miner_stats2 "$stats" \
			'{"params": {$miner2, $total_khs2, $miner_stats2}}')
	fi

	miner_stats $MINER #khs and stats are global

	echo -en "Hashrate ${CYAN}$MINER${NOCOLOR} `[[ $khs > 0 ]] && echo -e ${YELLOW} || echo -e ${RED}`$khs${NOCOLOR} kH/s"
	[[ ! -z $MINER2 ]] &&
		echo -en " ${CYAN}$MINER2${NOCOLOR} `[[ $khs2 > 0 ]] && echo -e ${YELLOW} || echo -e ${RED}`$khs2${NOCOLOR} kH/s"
	echo -en "\n"
	echo $khs > /run/hive/khs



	#echo $stats
	#uptime: load averages for the past 1, 5, and 15 minutes

	request=$(
	jq -n \
	--arg rig_id "$RIG_ID" \
	--arg passwd "$RIG_PASSWD" \
	--arg miner "$MINER" \
	--argjson miner_stats "$stats" \
	--arg total_khs "$khs" \
	--argjson temp "$temp" \
	--argjson fan "$fan" \
	--argjson power "$power" \
	--arg df "`df -h / | awk '{ print $4 }' | tail -n 1 | sed 's/%//'`" \
	--argjson cpuavg "[`uptime | awk -F': ' '{print $2}'`]" \
	'{
		"method": "stats", "jsonrpc": "2.0", "id": 0,
		"params": {
			$rig_id, $passwd, $miner, $miner_stats, $total_khs,
			$temp, $fan, $power, $df, $cpuavg
		}
	}'
	)

	[[ ! -z $miner2_json ]] && #add miner2 stats to json
		request=`echo "$request" "$miner2_json" | jq -s '.[0] * .[1]'`

	echo $request | jq '.' -c

	#log request
	echo "[`date`] > `echo $request | jq '.' -c`" >> $LOG
	#echo "[`date`] > $request" >> $LOG

	response=$(echo $request | curl --insecure -L --data @- \
	--connect-timeout 7 --max-time 15 --silent \
	-XPOST "${HIVE_URL}?id_rig=$RIG_ID&method=stats"  -H "Content-Type: application/json")

	exitcode=$?
	if [[ $exitcode -ne 0 || -z $response ]]; then
		echo -e "${RED}Error sending stats${NOCOLOR} $HIVE_HOST_URL" && human-curl-error $exitcode
		echo "[`date`] < ERROR SENDING STATS TO $HIVE_HOST_URL (curl code=$exitcode) \"$response\"" >> $LOG
		return $exitcode
	fi

	#echo $response
	#echo "[`date`] < `echo $response | jq '.' -c`" >> $LOG
	echo "[`date`] < $response" >> $LOG #full response even invalid

	error=$(echo $response | jq '.error' --raw-output)
	[[ $? != 0 ]] && echo -e "${RED}Invalid response${NOCOLOR}: $HIVE_HOST_URL\n$response" && return 1
	[[ ! -z $error && $error != "null" ]] && echo -e "${RED}Error response${NOCOLOR}: $error" && return 1

	command=$(echo $response | jq '.result.command' --raw-output)

	[[ $command != "OK" ]] && echo "$response" | jq '.result'


	if [[ $command != "batch" ]]; then
		body=`echo $response | jq -c '.result'`
		do_command
	else
		count=`echo $response | jq '.result.commands|length'`
		echo "Got $count batch commands"
		for (( i=0; i < $count; i++ )); do
			body=`echo $response | jq -c ".result.commands[$i]"`
			command=
			do_command
		done
	fi
}


########################################################################################################################

function oc_if_changed {
	nvidia_oc=$(echo $body | jq '.nvidia_oc' --raw-output)
	nvidia_oc_old=`[[ -e $NVIDIA_OC_CONF ]] && cat $NVIDIA_OC_CONF`
	[[ ! -z $nvidia_oc && $nvidia_oc != "null" && $nvidia_oc != $nvidia_oc_old ]] &&
		nvidia_oc_changed=1 || nvidia_oc_changed=

	amd_oc=$(echo $body | jq '.amd_oc' --raw-output)
	amd_oc_old=`[[ -e $AMD_OC_CONF ]] && cat $AMD_OC_CONF`
	[[ ! -z $amd_oc && $amd_oc != "null" && $amd_oc != $amd_oc_old ]] &&
		amd_oc_changed=1 || amd_oc_changed=

	[[ $justwrite != 1 && ! -z $nvidia_oc_changed || ! -z $amd_oc_changed ]] &&
		echo -e "${YELLOW}Stopping miner before Overclocking${NOCOLOR}" &&
		miner stop

	if [[ ! -z $nvidia_oc_changed ]]; then
		#echo -e "${YELLOW}Saving Nvidia OC config${NOCOLOR}"
		echo "$nvidia_oc" > $NVIDIA_OC_CONF && sync
		if [[ $justwrite != 1 ]]; then
			nvidia-oc-log
			exitcode=$?
			payload=`cat /var/log/nvidia-oc.log`
			echo "$payload"
			[[ $exitcode == 0 ]] &&
				echo "$payload" | message ok "Nvidia settings applied" payload ||
				echo "$payload" | message warn "Nvidia settings applied with errors, check X server running" payload
		fi
	fi

	if [[ ! -z $amd_oc_changed ]]; then
		#echo -e "${YELLOW}Saving AMD OC config${NOCOLOR}"
		echo "$amd_oc" > $AMD_OC_CONF && sync
		if [[ $justwrite != 1 ]]; then
			amd-oc-safe
			exitcode=$?
			payload=`cat /var/log/amd-oc.log`
			echo "$payload"
			[[ $exitcode == 0 ]] &&
				echo "$payload" | message ok "AMD settings applied" payload ||
				echo "$payload" | message warn "AMD settings applied with errors" payload
		fi
	fi
}

function do_command {
	#body=$1
	[[ -z $command ]] && command=`echo $body | jq -r '.command'` #get command for batch

	case $command in
		OK)
			echo -e "${BGREEN}$command${NOCOLOR}"
		;;
		reboot)
			message ok "Rebooting" 120
			echo -e "${BRED}Rebooting${NOCOLOR}"
			nohup bash -c 'sreboot' > /tmp/nohup.log 2>&1 &
			#superreboot
		;;
		upgrade)
			nohup bash -c '
				payload=`selfupgrade 2>&1`
				upgrade_exitcode=$?
				echo "$payload"
				[[ $upgrade_exitcode -eq 0 ]] &&
					echo "$payload" | message ok "Selfupgrade successful" payload ||
					echo "$payload" | message error "Selfupgrade failed" payload
			' > /tmp/nohup.log 2>&1 &
		;;
		exec)
			exec=$(echo $body | jq '.exec' --raw-output)
			payload=`bash -c "$exec" 2>&1`
			exitcode=$?
			echo "$payload"
			[[ $exitcode -eq 0 ]] &&
				echo "$payload" | message info "$exec" payload ||
				echo "$payload" | message error "Exec failed, exitcode=$exitcode" payload
		;;
		config)
			config=$(echo $body | jq '.config' --raw-output)
			justwrite=$(echo $body | jq '.justwrite' --raw-output) #don't restart miner, just write config, maybe WD settings will be updated
			if [[ ! -z $config && $config != "null" ]]; then
				#scan for password change
				echo "$config" > /tmp/rig.conf.new
				while read line; do
					[[ $line =~ ^RIG_PASSWD=\"(.*)\" ]] && NEW_PASSWD=${BASH_REMATCH[1]} && break
				done < /tmp/rig.conf.new
				rm /tmp/rig.conf.new

				# Password change ---------------------------------------------------
				if [[ $RIG_PASSWD != $NEW_PASSWD ]]; then
					echo -e "${RED}New password:${NOCOLOR} $NEW_PASSWD";

					message warning "Password change received, wait for next message..." 120
					request=$(jq -n --arg rig_id "$RIG_ID" --arg passwd "$RIG_PASSWD" \
					'{ "method": "password_change_received", "params": {$rig_id, $passwd}, "jsonrpc": "2.0", "id": 0}')
					response=$(echo $request | curl --insecure -L --data @- --connect-timeout 7 --max-time 15 --silent -XPOST "${HIVE_URL}?id_rig=$RIG_ID&method=password_change_received" -H "Content-Type: application/json")

					exitcode=$?
					[ $exitcode -ne 0 ] &&
						message error "Error notifying hive about \"password_change_received\"" &&
						return $exitcode #better exit because password will not be changed

					error=$(echo $response | jq '.error' --raw-output)
					[[ ! -z $error && $error != "null" ]] && echo -e "${RED}Server error:${NOCOLOR} `echo $response | jq '.error.message' -r`" && return 1

					echo "$response" | jq '.'
					#after this there will be new password on server, so all new request should use new one
				fi

				# Write new config and load it ---------------------------------------
				echo "$config" > $RIG_CONF && sync
				. $RIG_CONF

				# Save wallet if given -----------------------------------------------
				wallet=$(echo $body | jq '.wallet' --raw-output)
				[[ ! -z $wallet && $wallet != "null" ]] &&
					echo "$wallet" > $WALLET_CONF


				# Overclocking if given in config --------------------------------------
				oc_if_changed


				# Final actions ---------------------------------------------------------
				if [[ $justwrite != 1 ]]; then
					hostname-check
					miner restart
				fi

				# Start Watchdog. It will exit if WD_ENABLED=0 ---------------------------
				[[ $WD_ENABLED=1 ]] && wd restart

				message ok "Rig config changed" 120
				#[[ $? == 0 ]] && message ok "Wallet changed, miner restarted" 120 || message warn "Error restarting miner"
			else
				message error "No rig \"config\" given"
			fi
		;;
		wallet)
			wallet=$(echo $body | jq '.wallet' --raw-output)
			if [[ ! -z $wallet && $wallet != "null" ]]; then
				echo "$wallet" > $WALLET_CONF && sync

				justwrite=
				oc_if_changed

				miner restart
				[[ $? == 0 ]] && message ok "Wallet changed, miner restarted" 120 || message warn "Error restarting miner"
			else
				message error "No \"wallet\" config given"
			fi
		;;
		nvidia_oc)
			nvidia_oc=$(echo $body | jq '.nvidia_oc' --raw-output)
			#nvidia_oc_old=`[[ -e $NVIDIA_OC_CONF ]] && cat $NVIDIA_OC_CONF`
			#if [[ $nvidia_oc == $nvidia_oc_old ]]; then
			#	echo -e "${YELLOW}Nvidia OC config did not change, skipping${NOCOLOR}";
			if [[ ! -z $nvidia_oc && $nvidia_oc != "null" ]]; then
				echo "$nvidia_oc" > $NVIDIA_OC_CONF && sync
				nohup bash -c '
					nvidia-oc-log
					exitcode=$?
					payload=`cat /var/log/nvidia-oc.log`
					echo "$payload"
					[[ $exitcode == 0 ]] &&
						echo "$payload" | message ok "Nvidia settings applied" payload ||
						echo "$payload" | message warn "Nvidia settings applied with errors, check X server running" payload
				' > /tmp/nohup.log 2>&1 &
			else
				message error "No \"nvidia_oc\" config given"
			fi
		;;
		amd_oc)
			amd_oc=$(echo $body | jq '.amd_oc' --raw-output)
			#amd_oc_old=`[[ -e $AMD_OC_CONF ]] && cat $AMD_OC_CONF`
			#if [[ $amd_oc == $amd_oc_old ]]; then
			#	echo -e "${YELLOW}AMD OC config did not change, skipping${NOCOLOR}";
			if [[ ! -z $amd_oc && $amd_oc != "null" ]]; then
				echo "$amd_oc" > $AMD_OC_CONF && sync
				nohup bash -c '
					amd-oc-safe
					exitcode=$?
					payload=`cat /var/log/amd-oc.log`
					echo "$payload"
					[[ $exitcode == 0 ]] &&
						echo "$payload" | message ok "AMD settings applied" payload ||
						echo "$payload" | message warn "AMD settings applied with errors" payload
				' > /tmp/nohup.log 2>&1 &
			else
				message error "No \"amd_oc\" config given"
			fi
		;;
		amd_download)
			gpu_index=$(echo $body | jq '.gpu_index' --raw-output)
			listjson=`gpu-detect listjson AMD`
			gpu_biosid=`echo "$listjson" | jq -r ".[$gpu_index].vbios" | sed -e 's/[\,\.\ ]/_/g'`
			gpu_type=`echo "$listjson" | jq -r ".[$gpu_index].name" | sed -e 's/[\,\.\ ]//g'`
			gpu_memsize=`echo "$listjson" | jq -r ".[$gpu_index].mem" | sed -e 's/^\(..\).*/\1/' | sed -e 's/.$/G/'`
			gpu_memtype=`echo "$listjson" | jq -r ".[$gpu_index].mem_type" | sed -e 's/[\,\.\ ]//g'`
			if [[ ! -z $gpu_index && $gpu_index != "null" ]]; then
			    payload=`atiflash -s $gpu_index /tmp/amd.saved.rom`
			    exitcode=$?
			    echo "$payload"
				if [[ $exitcode == 0 ]]; then
					#payload=`cat /tmp/amd.saved.rom | base64`
					#echo "$payload" | message file "VBIOS $gpu_index" payload
					cat /tmp/amd.saved.rom | gzip -9 --stdout | base64 -w 0 | message file "vbios-$gpu_index-$gpu_type-$gpu_memsize-$gpu_memvendor-$gpu_biosid.rom" payload
				else
					echo "$payload" | message warn "AMD VBIOS saving failed" payload
				fi
			else
				message error "No \"gpu_index\" given"
			fi
		;;
		amd_upload)
			gpu_index=$(echo $body | jq '.gpu_index' --raw-output)
			rom_base64=$(echo $body | jq '.rom_base64' --raw-output)
			if [[ -z $gpu_index || $gpu_index == "null" ]]; then
				message error "No \"gpu_index\" given"
			elif [[ -z $rom_base64 || $rom_base64 == "null" ]]; then
				message error "No \"rom_base64\" given"
			else
				force=$(echo $body | jq '.force' --raw-output)
				[[ ! -z $force && $force == "1" ]] && extra_args="-f" || extra_args=""
				echo "$rom_base64" | base64 -d | gzip -d > /tmp/amd.uploaded.rom
				fsize=`cat /tmp/amd.uploaded.rom | wc -c`
				if [[ -z $fsize || $fsize < 250000 ]]; then #too short file
					message warn "ROM file size is only $fsize bytes, there is something wrong with it, skipping"
				else
					if [[ $gpu_index == -1 ]]; then # -1 = all
				    	payload=`atiflashall $extra_args /tmp/amd.uploaded.rom`
					else
				    	payload=`echo "=== Flashing card $gpu_index ===" && atiflash -p $gpu_index $extra_args /tmp/amd.uploaded.rom`
					fi
				    exitcode=$?
				    echo "$payload"
					if [[ $exitcode == 0 ]]; then
						echo "$payload" | message ok "ROM flashing OK, now reboot" payload
					else
						echo "$payload" | message warn "ROM flashing failed" payload
					fi
				fi
			fi
		;;
		openvpn_set)
			clientconf=$(echo $body | jq '.clientconf' --raw-output)
			cacrt=$(echo $body | jq '.cacrt' --raw-output)
			clientcrt_fname=$(echo $body | jq '.clientcrt_fname' --raw-output)
			clientcrt=$(echo $body | jq '.clientcrt' --raw-output)
			clientkey_fname=$(echo $body | jq '.clientkey_fname' --raw-output)
			clientkey=$(echo $body | jq '.clientkey' --raw-output)

			systemctl stop openvpn@client
			(rm /hive-config/openvpn/*.crt; rm /hive-config/openvpn/*.key; rm /hive-config/openvpn/*.conf) > /dev/null 2>&1

			echo "$clientconf" > /hive-config/openvpn/client.conf
			[[ ! -z $cacrt && $cacrt != "null" ]] && echo "$cacrt" > /hive-config/openvpn/ca.crt
			[[ ! -z $clientcrt && $clientcrt != "null" ]] && echo "$clientcrt" > /hive-config/openvpn/$clientcrt_fname
			[[ ! -z $clientkey && $clientkey != "null" ]] && echo "$clientkey" > /hive-config/openvpn/$clientkey_fname

			payload=`openvpn-install`
			exitcode=$?
			[[ $exitcode == 0 ]] && payload+=$'\n'"`hostname -I`"
			echo "$payload"
			if [[ $exitcode == 0 ]]; then
				echo "$payload" | message ok "OpenVPN configured" payload
				hello #to give new ips and openvpn flag
			else
				echo "$payload" | message warn "OpenVPN setup failed" payload
			fi
		;;
		openvpn_remove)
			systemctl stop openvpn@client
			(rm /hive-config/openvpn/*.crt; rm /hive-config/openvpn/*.key; rm /hive-config/openvpn/*.conf) > /dev/null 2>&1
			openvpn-install #will remove /tmp/.openvpn-installed file
			hello
			message ok "OpenVPN service stopped, certificates removed"
		;;
		"")
			echo -e "${YELLOW}Got empty command, might be temporary network issue${NOCOLOR}"
		;;
		*)
			message warning "Got unknown command \"$command\""
			echo -e "${YELLOW}Got unknown command ${CYAN}$command${NOCOLOR}"
		;;
	esac

	#Flush buffers if any files changed
	sync
}



########################################################################################################################

echo -e "\n\n[`date`] Started" >> $LOG

while true
do
	time_start=`date +%s`
	loop
	time_finish=`date +%s`

	wasted=$(( $time_finish - $time_start ))

	tosleep=$(( $INTERVAL - $wasted ))

	#echo "Sleeping $tosleep"
	echo ""

	if [[ $tosleep > 0 ]]; then
		sleep $INTERVAL
	else
		echo -e "${YELLOW}WARNING: Stats sending interval > $INTERVAL seconds, hanging driver?${NOCOLOR}"
	fi
done
